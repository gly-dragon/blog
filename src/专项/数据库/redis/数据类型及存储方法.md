---
title: 数据类型及存储方法
tags:
  - redis
  - 数据库
order: "2"
---

## 数据类型

redis中存在5种数据类型，分别是：

1. string：字符串类型
1. hash：散列类型 （map类型，一个键可以包含多个字段，每个字段有自己的值）
1. list：列表类型
1. set：无序集合类型
1. zset：有序集合类型

*redis的数据类型名均为小写*

## 不同类型数据存取及主要方法、主要特性

### string

**数据结构：** String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS）。是可以修改的字符串，内 部结构上类似于Java的ArrayList，采用分配冗余空间的方式来减少内存的频繁分配，字符串最大长度为512MB。

存：set 键 值

取：get 键（键不存在返回null）

一次存多个数据：mset 键1 值1 键2 值2....

一次取多个数据：mget 键1 键2 ...

string类型存储数据除了存储普通字符串外还可以用来存储json类型的字符串

**string类型的主要方法：**

1. 如果当前键对应的值是数值类型
   - incr 键：在当前值上加1
   - decr 键：在当前值上减1
   - increby 键 5：在当前值上加5
   - decreby 键 5：在当前值上减5
   
1. 判断键对应的值字符长度： strlen 键

1. 删除键：del 键

1. 将给定的value追加到原值的末尾：append 键 值

1. 键不存在时设置键的值： setnx 键 值 （键存在返回0，设置失败）

1. 多个键不存在时设置成功：msetnx 键1 值1 键2 值2...

1. 截取字符串：getrange 键 开始下标 结束下标

1. 覆盖指定位置的值：setrange 键 起始位置 值

   ```
   127.0.0.1:6379> set k1 helloworld
   OK
   127.0.0.1:6379> get k1
   "helloworld"
   127.0.0.1:6379> setrange k1 1 java
   (integer) 10
   127.0.0.1:6379> get k1
   "hjavaworld"
   ```

1. 设置键过期时间：setex 键 过期时间（秒） 值

1. 以新换旧，设置新值同时返回旧值：getset 键 值

   ```
   127.0.0.1:6379> set name ready #设置name为ready
   OK
   127.0.0.1:6379> getset name tom #设置name为tom，返回name的旧值
   "ready"
   127.0.0.1:6379> getset age 30 #设置age为30，age未设置过，返回age的旧值为null
   (nil)
   ```

------

### hash

Redis hash是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似于java里面的Map

**数据结构：** Hash类型对应的数据结构是2中：ziplist（压缩列表），hashtable（哈希表）。 当field-value长度较短个数较少时，使用ziplist，否则使用hashtable

存：hset 键 字段 值

取：hget 键 字段

一次存多个：hmset 键 字段1 值1 字段2 值2..

一次取多个：hmget 键  字段1 字段2...

**主要方法：**

1. 获得键中包含的所有字段：hkeys 键
1. 获得键包含的所有值 ：hvals 键
1. 删除键中某一个字段：hdel 字段
1. 判断键中是否包含某一个字段：hexists 键 字段
1. 获取所有字段和值：hgetall 键
1. 获得所有字段的数量：hlen 键
1. 给字段的值加上指定增量：hincrby 键 字段 增量
1. 当字段不存在时，设置字段的值：hsetnx 键 字段 值

------

### list

redis列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际上是使用双向链表实现的，对两端的操作性能很高，通过索引下标操作中间节点性能会较差。

**数据结构：** List的数据结构为快速链表quickList， 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也就是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当就比较多的时候才会改成quickList。

存：lpush 键 值1 值2 值2...                    从左到右添加

​		rpush 键 值1 值2 值2...                   从右至左添加

取：lpop 键               取列表中最左侧的元素

​		rpop 键              取列表中最右侧的元素

**主要方法：**

1. 获得列表中的元素个数：llen 键

2. 从列表左边获取指定范围内的值：lrange 键 开始索引 结束索引

3. 从列表右边取出一个值放入另一个列表： rpoplpush 键 键

4. 获取指定索引位置出的元素（从左到右）：lindex 键 index

5. 在某个值的前或者后面插入一个值：linsert 键 before|after 值 新插入的值

   > 如果命令执行成功，返回插入操作完成之后，列表的长度。 
   >
   > 如果没有找到 value ，返回 -1 。 
   >
   > 如果 key 不存在或为空列表，返回 0 。

   ```
   127.0.0.1:6379> rpush name ready tom jack #列表name中添加3个元素
   (integer) 3
   127.0.0.1:6379> lrange name 0 -1 #name列表所有元素
   1) "ready"
   2) "tom"
   3) "jack"
   127.0.0.1:6379> linsert name before tom lily #tom前面添加lily
   (integer) 4
   127.0.0.1:6379> lrange name 0 -1 #name列表所有元素
   1) "ready"
   2) "lily"
   3) "tom"
   4) "jack"
   ```

6. 删除指定数量的某个元素：lrem 键 数量 值

7. 替换指定位置的值：lset 键 下标 值

   > 操作成功返回 ok ，否则返回错误信息。

------

### set

set类型存放的数据无序排列，不允许有重复元素，取值时是随机取，取一个少一个。

set是string类型的无序集合，他的底层实际是一个value为null的hash表，收益添加，删除，查 找复杂度都是O(1)。 一个算法，如果时间复杂度是O(1)，那么随着数据的增加，查找数据的时间不变，也就是不管数据多 少，查找时间都是一样的。

**数据结构：** set数据结构是字典，字典是用hash表实现的。 Java中的HashSet的内部实现使用HashMap，只不过所有的value都指向同一个对象。 Redis的set结构也是一样的，它的内部也使用hash结构，所有的value都指向同一个内部值。

存：sadd 键  值1 值2 值3

取：spop 键

**主要方法**

1. 取出所有元素：smembers 键

1. 判断是否有某个值：sismember 键  值

1. 获取集合中元素的个数：scard 键

1. 删除多个元素：srem 键 值1 值2...

1. 随机取多个值：spop 键 数量

1. 随机获取多个元素，不会从集合中删除：srandmember 键 数量

1. 将元素从一个集合移动到另一个集合：smove 键1 键2 值

   > 把值从键1移动到键2，成功返回1，失败返回0
   >
   > 当键1、jian2不是集合类型时返回错误信息

1. 取多个集合的交集：sinter 键1 键2...

1. 将多个集合的交集放到一个新的集合中sinterstore 键1 键2 键3...

   > 把键2，键3...的交集放入到键1中

1. 取多个集合的并集，自动去重:sunion 键1 键2...

1. 将多个集合的并集放到一个新的集合中：sunionstore 键1 键2 键3...

   > 把键2，键3...的并集去重后放入到键1中

1. 取多个集合的差集：sdiff 键1 键2

1. 将多个集合的差集放到一个新的集合中：sdiffstore 键1 键2 键3...

------

### zset

redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分 到最高分的方式排序集合中的成员。 集合的成员是唯一的，但是评分是可以重复的。

**数据结构：** zset内部使用了两种数据结构，分别是hash表和跳表。

存：zadd  键   分数1  值1  分数2 值2

**主要方法：**

1. 遍历数据：zrange 键  0 -1（-1表示遍历的是所有数据）
1. 遍历时同时显示分数(默认升序)：zrange 键  0 -1 withscores
1. 遍历时同时显示分数（降序）：zrevrange 键  0 -1 withscores
1. 按分数升序排列，获取指定分数范围的数据：zrangebyscore 键 分数1 分数2
1. 按分数降序排列，获取指定分数范围的数据：zrevrangebyscore 键 分数1 分数2
1. 为指定元素的分数加上指定的增量：zincrby 键 增量 值
1. 删除多个元素：zrem 键 值1 值2...
1. 根据索引范围删除元素（包括开始、结束下标）：zremrangebyrank 键 开始下标 结束下标
1. 根据分数的范围删除元素：zremrangebyscore 键 分数1 分数2
1. 获取指定分数范围内的元素个数：zcount 键 分数1 分数2
1. 按分数升序排列，返回某个元素在集合中的排名：zrank 键 值
1. 按分数降序排列，返回某个元素在集合中的排名：zrevrank 键 值
1. 获取指定元素的分数：zscore 键 值

## redis数据库操作的一些方法

1. 清空所有数据：flushall
1. 清空当前数据库：flushdb
1. 查询有哪些键：keys *
1. 删除某一个键：del 键 
1. 判断是否存在某一个键:  exists 键
1. 判断当前值的数据类型：  type 键
1. 设置存放数据的过期时间（默认永不过期）：expire 键 秒（前提：键存在）
1. 查看某一个键的过期时间ttl 键
1. 切换数据库：select dbindex
1. 查看当前数据库键的数量：dbsize

