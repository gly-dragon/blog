import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as l,e as t}from"./app-CULDOIHg.js";const s={},n=t(`<h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><p>redis中存在5种数据类型，分别是：</p><ol><li>string：字符串类型</li><li>hash：散列类型 （map类型，一个键可以包含多个字段，每个字段有自己的值）</li><li>list：列表类型</li><li>set：无序集合类型</li><li>zset：有序集合类型</li></ol><p><em>redis的数据类型名均为小写</em></p><h2 id="不同类型数据存取及主要方法、主要特性" tabindex="-1"><a class="header-anchor" href="#不同类型数据存取及主要方法、主要特性"><span>不同类型数据存取及主要方法、主要特性</span></a></h2><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string"><span>string</span></a></h3><p>**数据结构：**String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS）。是可以修改的字符串，内 部结构上类似于Java的ArrayList，采用分配冗余空间的方式来减少内存的频繁分配，字符串最大长度为512MB。</p><p>存：set 键 值</p><p>取：get 键（键不存在返回null）</p><p>一次存多个数据：mset 键1 值1 键2 值2....</p><p>一次取多个数据：mget 键1 键2 ...</p><p>string类型存储数据除了存储普通字符串外还可以用来存储json类型的字符串</p><p><strong>string类型的主要方法：</strong></p><ol><li><p>如果当前键对应的值是数值类型</p><ul><li>incr 键：在当前值上加1</li><li>decr 键：在当前值上减1</li><li>increby 键 5：在当前值上加5</li><li>decreby 键 5：在当前值上减5</li></ul></li><li><p>判断键对应的值字符长度： strlen 键</p></li><li><p>删除键：del 键</p></li><li><p>将给定的value追加到原值的末尾：append 键 值</p></li><li><p>键不存在时设置键的值： setnx 键 值 （键存在返回0，设置失败）</p></li><li><p>多个键不存在时设置成功：msetnx 键1 值1 键2 值2...</p></li><li><p>截取字符串：getrange 键 开始下标 结束下标</p></li><li><p>覆盖指定位置的值：setrange 键 起始位置 值</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>127.0.0.1:6379&gt; set k1 helloworld
OK
127.0.0.1:6379&gt; get k1
&quot;helloworld&quot;
127.0.0.1:6379&gt; setrange k1 1 java
(integer) 10
127.0.0.1:6379&gt; get k1
&quot;hjavaworld&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>设置键过期时间：setex 键 过期时间（秒） 值</p></li><li><p>以新换旧，设置新值同时返回旧值：getset 键 值</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>127.0.0.1:6379&gt; set name ready #设置name为ready
OK
127.0.0.1:6379&gt; getset name tom #设置name为tom，返回name的旧值
&quot;ready&quot;
127.0.0.1:6379&gt; getset age 30 #设置age为30，age未设置过，返回age的旧值为null
(nil)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><hr><h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash"><span>hash</span></a></h3><p>Redis hash是一个键值对集合。 Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 类似于java里面的Map</p><p>**数据结构：**Hash类型对应的数据结构是2中：ziplist（压缩列表），hashtable（哈希表）。 当field-value长度较短个数较少时，使用ziplist，否则使用hashtable</p><p>存：hset 键 字段 值</p><p>取：hget 键 字段</p><p>一次存多个：hmset 键 字段1 值1 字段2 值2..</p><p>一次取多个：hmget 键 字段1 字段2...</p><p><strong>主要方法：</strong></p><ol><li>获得键中包含的所有字段：hkeys 键</li><li>获得键包含的所有值 ：hvals 键</li><li>删除键中某一个字段：hdel 字段</li><li>判断键中是否包含某一个字段：hexists 键 字段</li><li>获取所有字段和值：hgetall 键</li><li>获得所有字段的数量：hlen 键</li><li>给字段的值加上指定增量：hincrby 键 字段 增量</li><li>当字段不存在时，设置字段的值：hsetnx 键 字段 值</li></ol><hr><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>list</span></a></h3><p>redis列表是简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边）。它的底层实际上是使用双向链表实现的，对两端的操作性能很高，通过索引下标操作中间节点性能会较差。</p><p>**数据结构：**List的数据结构为快速链表quickList， 首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也就是压缩列表。 它将所有的元素紧挨着一起存储，分配的是一块连续的内存。 当就比较多的时候才会改成quickList。</p><p>存：lpush 键 值1 值2 值2... 从左到右添加</p><p>​ rpush 键 值1 值2 值2... 从右至左添加</p><p>取：lpop 键 取列表中最左侧的元素</p><p>​ rpop 键 取列表中最右侧的元素</p><p><strong>主要方法：</strong></p><ol><li><p>获得列表中的元素个数：llen 键</p></li><li><p>从列表左边获取指定范围内的值：lrange 键 开始索引 结束索引</p></li><li><p>从列表右边取出一个值放入另一个列表： rpoplpush 键 键</p></li><li><p>获取指定索引位置出的元素（从左到右）：lindex 键 index</p></li><li><p>在某个值的前或者后面插入一个值：linsert 键 before|after 值 新插入的值</p><blockquote><p>如果命令执行成功，返回插入操作完成之后，列表的长度。</p><p>如果没有找到 value ，返回 -1 。</p><p>如果 key 不存在或为空列表，返回 0 。</p></blockquote><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>127.0.0.1:6379&gt; rpush name ready tom jack #列表name中添加3个元素
(integer) 3
127.0.0.1:6379&gt; lrange name 0 -1 #name列表所有元素
1) &quot;ready&quot;
2) &quot;tom&quot;
3) &quot;jack&quot;
127.0.0.1:6379&gt; linsert name before tom lily #tom前面添加lily
(integer) 4
127.0.0.1:6379&gt; lrange name 0 -1 #name列表所有元素
1) &quot;ready&quot;
2) &quot;lily&quot;
3) &quot;tom&quot;
4) &quot;jack&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>删除指定数量的某个元素：lrem 键 数量 值</p></li><li><p>替换指定位置的值：lset 键 下标 值</p><blockquote><p>操作成功返回 ok ，否则返回错误信息。</p></blockquote></li></ol><hr><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>set</span></a></h3><p>set类型存放的数据无序排列，不允许有重复元素，取值时是随机取，取一个少一个。</p><p>set是string类型的无序集合，他的底层实际是一个value为null的hash表，收益添加，删除，查 找复杂度都是O(1)。 一个算法，如果时间复杂度是O(1)，那么随着数据的增加，查找数据的时间不变，也就是不管数据多 少，查找时间都是一样的。</p><p>**数据结构：**set数据结构是字典，字典是用hash表实现的。 Java中的HashSet的内部实现使用HashMap，只不过所有的value都指向同一个对象。 Redis的set结构也是一样的，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><p>存：sadd 键 值1 值2 值3</p><p>取：spop 键</p><p><strong>主要方法</strong></p><ol><li><p>取出所有元素：smembers 键</p></li><li><p>判断是否有某个值：sismember 键 值</p></li><li><p>获取集合中元素的个数：scard 键</p></li><li><p>删除多个元素：srem 键 值1 值2...</p></li><li><p>随机取多个值：spop 键 数量</p></li><li><p>随机获取多个元素，不会从集合中删除：srandmember 键 数量</p></li><li><p>将元素从一个集合移动到另一个集合：smove 键1 键2 值</p><blockquote><p>把值从键1移动到键2，成功返回1，失败返回0</p><p>当键1、jian2不是集合类型时返回错误信息</p></blockquote></li><li><p>取多个集合的交集：sinter 键1 键2...</p></li><li><p>将多个集合的交集放到一个新的集合中sinterstore 键1 键2 键3...</p><blockquote><p>把键2，键3...的交集放入到键1中</p></blockquote></li><li><p>取多个集合的并集，自动去重:sunion 键1 键2...</p></li><li><p>将多个集合的并集放到一个新的集合中：sunionstore 键1 键2 键3...</p><blockquote><p>把键2，键3...的并集去重后放入到键1中</p></blockquote></li><li><p>取多个集合的差集：sdiff 键1 键2</p></li><li><p>将多个集合的差集放到一个新的集合中：sdiffstore 键1 键2 键3...</p></li></ol><hr><h3 id="zset" tabindex="-1"><a class="header-anchor" href="#zset"><span>zset</span></a></h3><p>redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。 不同之处是有序集合的每个成员都关联了一个评分（score），这个评分（score）被用来按照从最低分 到最高分的方式排序集合中的成员。 集合的成员是唯一的，但是评分是可以重复的。</p><p>**数据结构：**zset内部使用了两种数据结构，分别是hash表和跳表。</p><p>存：zadd 键 分数1 值1 分数2 值2</p><p><strong>主要方法：</strong></p><ol><li>遍历数据：zrange 键 0 -1（-1表示遍历的是所有数据）</li><li>遍历时同时显示分数(默认升序)：zrange 键 0 -1 withscores</li><li>遍历时同时显示分数（降序）：zrevrange 键 0 -1 withscores</li><li>按分数升序排列，获取指定分数范围的数据：zrangebyscore 键 分数1 分数2</li><li>按分数降序排列，获取指定分数范围的数据：zrevrangebyscore 键 分数1 分数2</li><li>为指定元素的分数加上指定的增量：zincrby 键 增量 值</li><li>删除多个元素：zrem 键 值1 值2...</li><li>根据索引范围删除元素（包括开始、结束下标）：zremrangebyrank 键 开始下标 结束下标</li><li>根据分数的范围删除元素：zremrangebyscore 键 分数1 分数2</li><li>获取指定分数范围内的元素个数：zcount 键 分数1 分数2</li><li>按分数升序排列，返回某个元素在集合中的排名：zrank 键 值</li><li>按分数降序排列，返回某个元素在集合中的排名：zrevrank 键 值</li><li>获取指定元素的分数：zscore 键 值</li></ol><h2 id="redis数据库操作的一些方法" tabindex="-1"><a class="header-anchor" href="#redis数据库操作的一些方法"><span>redis数据库操作的一些方法</span></a></h2><ol><li>清空所有数据：flushall</li><li>清空当前数据库：flushdb</li><li>查询有哪些键：keys *</li><li>删除某一个键：del 键</li><li>判断是否存在某一个键: exists 键</li><li>判断当前值的数据类型： type 键</li><li>设置存放数据的过期时间（默认永不过期）：expire 键 秒（前提：键存在）</li><li>查看某一个键的过期时间ttl 键</li><li>切换数据库：select dbindex</li><li>查看当前数据库键的数量：dbsize</li></ol>`,52),a=[n];function r(p,d){return i(),l("div",null,a)}const h=e(s,[["render",r],["__file","数据类型及存储方法.html.vue"]]),m=JSON.parse('{"path":"/database/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95.html","title":"数据类型及存储方法","lang":"zh-CN","frontmatter":{"title":"数据类型及存储方法","tags":["redis"],"description":"数据类型 redis中存在5种数据类型，分别是： string：字符串类型 hash：散列类型 （map类型，一个键可以包含多个字段，每个字段有自己的值） list：列表类型 set：无序集合类型 zset：有序集合类型 redis的数据类型名均为小写 不同类型数据存取及主要方法、主要特性 string **数据结构：**String的数据结构为简单动...","head":[["meta",{"property":"og:url","content":"https://gly-dragon.github.io/blog/blog/database/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%AD%98%E5%82%A8%E6%96%B9%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"书元"}],["meta",{"property":"og:title","content":"数据类型及存储方法"}],["meta",{"property":"og:description","content":"数据类型 redis中存在5种数据类型，分别是： string：字符串类型 hash：散列类型 （map类型，一个键可以包含多个字段，每个字段有自己的值） list：列表类型 set：无序集合类型 zset：有序集合类型 redis的数据类型名均为小写 不同类型数据存取及主要方法、主要特性 string **数据结构：**String的数据结构为简单动..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-31T15:36:02.000Z"}],["meta",{"property":"article:author","content":"龙哥不管事"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:modified_time","content":"2024-03-31T15:36:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据类型及存储方法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-31T15:36:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"龙哥不管事\\",\\"url\\":\\"https://gly-dragon.github.io/blog/\\"}]}"]]},"headers":[{"level":2,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":2,"title":"不同类型数据存取及主要方法、主要特性","slug":"不同类型数据存取及主要方法、主要特性","link":"#不同类型数据存取及主要方法、主要特性","children":[{"level":3,"title":"string","slug":"string","link":"#string","children":[]},{"level":3,"title":"hash","slug":"hash","link":"#hash","children":[]},{"level":3,"title":"list","slug":"list","link":"#list","children":[]},{"level":3,"title":"set","slug":"set","link":"#set","children":[]},{"level":3,"title":"zset","slug":"zset","link":"#zset","children":[]}]},{"level":2,"title":"redis数据库操作的一些方法","slug":"redis数据库操作的一些方法","link":"#redis数据库操作的一些方法","children":[]}],"git":{"createdTime":1711899362000,"updatedTime":1711899362000,"contributors":[{"name":"龙哥不管事","email":"3498347531@qq.com","commits":1}]},"readingTime":{"minutes":7.92,"words":2377},"filePathRelative":"database/redis/数据类型及存储方法.md","localizedDate":"2024年3月31日","excerpt":"<h2>数据类型</h2>\\n<p>redis中存在5种数据类型，分别是：</p>\\n<ol>\\n<li>string：字符串类型</li>\\n<li>hash：散列类型 （map类型，一个键可以包含多个字段，每个字段有自己的值）</li>\\n<li>list：列表类型</li>\\n<li>set：无序集合类型</li>\\n<li>zset：有序集合类型</li>\\n</ol>\\n<p><em>redis的数据类型名均为小写</em></p>\\n<h2>不同类型数据存取及主要方法、主要特性</h2>\\n<h3>string</h3>\\n<p>**数据结构：**String的数据结构为简单动态字符串（Simple Dynamic String，缩写SDS）。是可以修改的字符串，内 部结构上类似于Java的ArrayList，采用分配冗余空间的方式来减少内存的频繁分配，字符串最大长度为512MB。</p>","autoDesc":true}');export{h as comp,m as data};
